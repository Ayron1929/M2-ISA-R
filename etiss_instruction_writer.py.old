from lark import Transformer, v_args, Discard
from model_classes import DataType, InstrAttribute
from collections import defaultdict
from functools import partial

data_type_map = {
    DataType.S: 'etiss_int32',
    DataType.U: 'etiss_uint32',
    DataType.NONE: 'etiss_uint32'
}

class CodeString:
    def __init__(self, code, static, pre_code=None, post_code=None):
        self.code = code
        self.static = static
        self.pre_code = pre_code
        self.post_code = post_code

class Variable:
    def __init__(self):
        self.value = None
        self.size = 32
        self.signed = False
    
    @property
    def static(self):
        return bool(self.value)

class EtissInstructionWriter(Transformer):
    def __init__(self, constants, spaces, regs, fields, attribs, instr_size):
        self.__constants = constants
        self.__spaces = spaces
        self.__regs = regs
        self.__fields = fields
        self.__attribs = attribs if attribs else []
        self.__scalars = {}
        self.pc_modified = False
        self.instr_size = instr_size
        self.generates_exception = False
        self.temp_var_count = 0
    
    def operation(self, args):
        if InstrAttribute.NO_CONT in self.__attribs:
            if self.generates_exception:
                args.insert(0, 'etiss_uint32 exception = 0;')
                args.append('partInit.code() += "if exception return exception;"')
            else:
                args.append('partInit.code() += "return 0;"')
        else:
            args.append(f'partInit.code() += "PC += {int(self.instr_size/8)};"')

        if self.generates_exception:
            args.insert(0, 'etiss_uint32 exception = 0;')
            args.append('partInit.code() += "if exception return exception;"')

        return '\n'.join(args)

    def scalar_definition(self, args):
        name, dtype, size = args
        if type(size) != int:
            size = self.__constants[size].value
        
        self.__scalars[name] = size
        return CodeString(f'etiss_int{size} {name}', True)

    def fn_args(self, args):
        return args
    
    def function(self, args):
        name, fn_args = args
        if name.value == 'choose':
            cond, then_stmts, else_stmts = fn_args
            return CodeString(f'{cond.code} ? {then_stmts.code} : {else_stmts.code}', False not in [x.static for x in fn_args])
        elif name.value == 'sext':
            op, = fn_args
            return op
        
        args_str = ', '.join([x.code for x in fn_args])
        return CodeString(f'{name}({args_str})', False)

    def conditional(self, args):
        cond, then_stmts, else_stmts = args
        temp = f'if ({cond.code}) {{\n\t'

        if not cond.static:
            temp = f'partInit.code() += "{temp}";'

        temp += '\n\t'.join(then_stmts)
        temp += '\n}'
        
        if else_stmts:
            temp += 'else {'
            temp += '\n\t'.join(else_stmts)
            temp += '\n}'
        
        return temp
    
    def then_stmts(self, args):
        return args

    def else_stmts(self, args):
        return args

    def assignment(self, args):
        target, bit_size, expr = args
             
        if expr.static and not target.static:
            expr.code = f'" + toString({expr.code}) + "'
        if expr.static and target.static:
            return f'{target.code} = {expr.code}'
        return f'partInit.code() += "{target.code} = {expr.code};"'

    def two_op_expr(self, args):
        left, op, right = args

        if not left.static and right.static:
            right.code = f'" + toString({right.code}) + "'
        if not right.static and left.static:
            left.code = f'" + toString({left.code}) + "'

        return CodeString(f'({left.code} {op.value} {right.code})', left.static and right.static)
    
    def unitary_expr(self, args):
        op, right = args
        return CodeString(f'({op} {right.code})', right.static)

    def value_ref(self, args):
        name, size = args
        if size:
            print('')
        return CodeString(name.code, name.static, name.pre_code)
    
    def named_reference(self, args):
        name, size = args
        return CodeString(name, name in self.__fields)
    
    def indexed_reference(self, args):
        name, index, size = args

        if index.static:
            index.code = f'" + toString({index.code}) + "'

        if name in self.__spaces:           
            self.generates_exception = True
            
            mem_size = size if size else self.__spaces[name].size
            
            mem_val = f'mem_val_{self.temp_var_count}'
            
            pre_code = post_code = f'etiss_uint{mem_size} {mem_val};\n'

            pre_code += f'exception = read_mem({name}, {index.code}, &{mem_val}, {mem_size});'
            post_code += f'exception = write_mem({name}, {index.code}, &{mem_val}, {mem_size});'
            
            self.temp_var_count += 1

            return CodeString(f'{mem_val}', False, pre_code, post_code)

        return CodeString(f'{name}[{index.code}]', False)

    def number_literal(self, args):
        lit, = args
        return CodeString(f'{lit}', True)
    
    def type_conv(self, args):
        expr, data_type = args
        return CodeString(f'({data_type_map[data_type]})({expr.code})', expr.static)