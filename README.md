# M2-ISA-R v2

This tool generates architecture models for [ETISS](https://github.com/tum-ei-eda/etiss) from CoreDSL source files or abstract model trees. It is the 2nd version of the M2-ISA-R tool (not to be confused with the CoreDSL language versions, of which this tool is only compatible with version 1, see [below](##CoreDSL)).

## CoreDSL
CoreDSL is a domain-specific language that models processor cores at the level of their instruction set architecture (ISA) by describing each instruction and its effects on the machine state using `.core_desc` files. For more information on CoreDSL, see the official [documentation](https://github.com/Minres/CoreDSL/wiki/CoreDSL-2-programmer's-manual). **IMPORTANT: The documentation describes the newer CoreDSL v2 language. This tool, however, uses CoreDSL v1. While both versions are similar, they are generally incompatible.** (Technically, this tool is only compatible with its own dialect of CoreDSL, unofficially called CoreDSL v1.5)

## Prerequisites
- Python 3.7+ with at least `pip` and `venv`

## Installation
- Clone the repository, change into its root
- Create a Python virtualenv: `python3 -m venv venv`
- Activate venv: `source venv/bin/activate` (might differ on Windows)
- Install Python dependencies: `pip install -r requirements.txt`

## Architecture
M2-ISA-R consists of 3 components, two of which are exchangeable for different needs:

Frontend -> Metamodel -> Backend

The frontend transforms a model specification into M2-ISA-R's internal architecture model. This model can then be transformed again to an output format, e.g. models for an ISS. This repo provides a CoreDSL frontend and an ETISS backend.

## Usage
M2-ISA-R v2 is divided into two separate tools: parser and writer. These are described below (`<top_level>` must be replaced with the name of the top-level file):

- To parse a CoreDSL description: `python -m m2isar.frontends.coredsl.parser [-j threads] path/to/input/<top_level>.core_desc`
- To generate an ETISS architecture: `python -m m2isar.backends.etiss.writer -s path/to/input/gen_model/<top_level>.m2isarmodel`

Notes:
- The input path to the parser `path/to/input/<top_level>.core_desc` should point to the top-level CoreDSL file (i.e. the file where `Core`s are defined).
- The internal architecture model file (i.e. the `.m2isarmodel` file), generated by the parser, is put into `path/to/input/gen_model`.
- The input path to the writer `path/to/input/gen_model/<top_level>.m2isarmodel` should point to the internal architecture model file generated by the parser.
- The architecture output files - generated by the writer - are put into `path/to/input/gen_output`. They characterize a processor core at the ISA level by supplying functions that can be called from an ISS. When using ETISS, place them into the [`ArchImpl/`](https://github.com/tum-ei-eda/etiss/tree/master/ArchImpl) directory.

### Parser:
Currently, a CoreDSL parser is provided. This parser understands the unofficial version 1.5 of CoreDSL. It is based on the original CoreDSL specification with some fixes backported from version 2.0, such as sized address spaces.

The parser can be called by `python -m m2isar.frontends.coredsl.parser`. Usage:

```
$ python -m m2isar.frontends.coredsl.parser --help
usage: parser.py [-h] [-j PARALLEL] [--log {critical,error,warning,info,debug}] top_level

positional arguments:
  top_level             The top-level CoreDSL file.

optional arguments:
  -h, --help            show this help message and exit
  -j PARALLEL           Use PARALLEL threads while parsing.
  --log {critical,error,warning,info,debug}
```

### Writer:
A writer backend for ETISS is provided. Call it like this: `python -m m2isar.backends.etiss.writer`. Usage:

```
$ python -m m2isar.backends.etiss.writer --help
usage: writer.py [-h] [-s] [--log {critical,error,warning,info,debug}] top_level

positional arguments:
  top_level             A .m2isarmodel file containing the models to generate.

optional arguments:
  -h, --help            show this help message and exit
  -s, --separate        Generate separate .cpp files for each instruction set.
  --log {critical,error,warning,info,debug}
```
