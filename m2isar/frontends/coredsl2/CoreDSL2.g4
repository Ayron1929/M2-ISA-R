/*
 * generated by Xtext 2.25.0
 */
grammar CoreDSL2;

// Rule DescriptionContent
description_content: imports+=import_file* definitions+=isa+;

// Rule Import
import_file: 'import' uri=RULE_STRING;

// Rule ISA
isa: instruction_set | core_def;

// Rule InstructionSet
instruction_set: 'InstructionSet' name=RULE_ID ('extends' extension=RULE_ID)? '{'
	(section_arch_state	(section_functions section_instructions? | section_instructions)?
	| section_functions	(section_arch_state	section_instructions? | section_instructions)?
	| section_instructions (section_arch_state section_functions? |	section_functions)?
	)
	'}'
;

// Rule CoreDef
core_def: 'Core' name=RULE_ID ('provides' contributing_types+=RULE_ID (',' contributing_types+=RULE_ID)*)? '{'
	(section_arch_state	(section_functions section_instructions? | section_instructions)?
	| section_functions	(section_arch_state	section_instructions? | section_instructions)?
	| section_instructions (section_arch_state section_functions? |	section_functions)?
	)
	'}'
;

// Rule SectionArchState
section_arch_state:	'architectural_state' '{' declarations+=decl_or_expr+ '}';

decl_or_expr: declaration | expression_statement;

// Rule SectionFunctions
section_functions: 'functions' '{' functions+=function_definition+ '}';

// Rule SectionInstructions
section_instructions: 'instructions' attributes+=attribute* '{' instructions+=instruction+ '}';

// Rule Instruction
instruction: name=RULE_ID attributes+=attribute* '{'
	'encoding' ':' encoding=rule_encoding';'
	('args_disass' ':' disass=RULE_STRING ';')?
	'behavior' ':' behavior=statement
	'}'
;

// Rule Encoding
rule_encoding: fields+=field ('::' fields+=field)*;

// Rule Field
field: bit_value | bit_field;

// Rule BitValue
bit_value: value=RULE_INTEGER;

// Rule BitField
bit_field: name=RULE_ID RULE_LEFT_BR left=integer_constant ':' right=integer_constant RULE_RIGHT_BR;

// Rule FunctionDefinition
function_definition:
	'extern' type_=type_specifier name=RULE_ID '(' parameter_list? ')' ';' # extern_function_definition
	| type_=type_specifier name=RULE_ID '(' parameter_list? ')' attributes+=attribute* behavior=compound_statement # intern_function_definition
;

// Rule ParameterList
parameter_list: params+=parameter_declaration (',' params+=parameter_declaration)*;

// Rule ParameterDeclaration
parameter_declaration: type_=type_specifier declarator=direct_or_abstract_declarator?;
direct_or_abstract_declarator: direct_declarator | abstract_declarator;
// Rule Statement
statement:
	compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	| spawn_statement
;

// Rule LabeledStatement
labeled_statement:
	'case' const_expr=constant_expression ':' items+=statement*
	| 'default' ':' items+=statement*
;

// Rule CompoundStatement
compound_statement: '{' items+=block_item* '}';

// Rule BlockItem
block_item: statement | declaration;

// Rule ExpressionStatement
expression_statement: expr=expression_list? ';';

// Rule SelectionStatement
selection_statement: if_statement | switch_statement;

// Rule IfStatement
if_statement: 'if' '(' cond=conditional_expression ')' then_stmt=statement ('else' else_stmt=statement)?;

// Rule SwitchStatement
switch_statement: 'switch' '(' cond=conditional_expression ')' '{' items+=labeled_statement+ '}';

// Rule IterationStatement
iteration_statement:
	type_='while' '(' cond=conditional_expression ')' stmt=statement
	| type_='do' stmt=statement 'while' '(' cond=conditional_expression ')' ';'
	| type_='for' '(' for_condition ')' stmt=statement
;

// Rule ForCondition
for_condition: (start_decl=declaration | start_expr=assignment_expression? ';') end_expr=conditional_expression? ';' (loop_exprs+=assignment_expression (',' loop_exprs+=assignment_expression)*)?;

// Rule JumpStatement
jump_statement:
	type_='continue' ';'
	| type_='break' ';'
	| type_='return' expr=conditional_expression? ';'
;

// Rule SpawnStatement
spawn_statement: 'spawn' stmt=statement;

// Rule Declaration
declaration: (storage+=storage_class_specifier | qualifiers+=type_qualifier | attributes+=attribute)* type_=type_specifier ptr=('*' | '&')? (init+=init_declarator (',' init+=init_declarator)*)? ';';

// Rule DeclarationSpecifier
declarationSpecifier: storage_class_specifier | type_qualifier | attribute;

// Rule Attribute
attribute: double_left_bracket type_=attribute_name ('=' value=conditional_expression)? double_right_bracket;

// Rule TypeSpecifier
type_specifier: primitive_type | composite_type | enum_type;

// Rule PrimitiveType
primitive_type: data_type=data_types+ bit_size=bit_size_specifier?;

// Rule BitSizeSpecifier
bit_size_specifier: '<' size+=primary_expression (',' size+=primary_expression ',' size+=primary_expression ',' size+=primary_expression)? '>';

// Rule EnumType
enum_type:
	'enum' name=RULE_ID? '{' enumerator_list ','? '}'
	| 'enum' name=RULE_ID
;

// Rule EnumeratorList
enumerator_list: enumerators+=enumerator (',' enumerators+=enumerator)*;

// Rule Enumerator
enumerator:
	name=RULE_ID
	| name=RULE_ID '=' constant_expression
;

// Rule CompositeType
composite_type:
	type_=struct_or_union name=RULE_ID? '{' declarations+=struct_declaration* '}'
	| type_=struct_or_union name=RULE_ID
;

// Rule StructDeclaration
struct_declaration: specifier=struct_declaration_specifier declarators+=direct_declarator(',' declarators+=direct_declarator)* ';';

// Rule StructDeclarationSpecifier
struct_declaration_specifier: type_=type_specifier | qualifiers+=type_qualifier;

// Rule InitDeclarator
init_declarator: declarator=direct_declarator attributes=attribute* ('=' init=initializer)?;

// Rule DirectDeclarator
direct_declarator:
	name=RULE_ID (':' index=integer_constant)?
		((RULE_LEFT_BR size+=conditional_expression RULE_RIGHT_BR)+
		| '(' parameter_list ')')?
;

// Rule Initializer
initializer:
	expr=conditional_expression
	| '{' initializerList ','? '}'
;

// Rule InitializerList
initializerList: init+=designated_or_not (',' init+=designated_or_not)*;
designated_or_not: designated_initializer | initializer;

// Rule DesignatedInitializer
designated_initializer: designators+=designator+ '=' init=initializer;

// Rule Designator
designator: RULE_LEFT_BR idx=constant_expression RULE_RIGHT_BR | '.' prop=RULE_ID;

// Rule AbstractDeclarator
abstract_declarator: direct_abstract_declarator;

// Rule DirectAbstractDeclarator
direct_abstract_declarator:
	'(' (decl=abstract_declarator? | parameter_list) ')'
	| RULE_LEFT_BR expr=constant_expression? RULE_RIGHT_BR
;

// Rule ExpressionList
expression_list: expressions+=assignment_expression (',' expressions+=assignment_expression)*;

// Rule AssignmentExpression
assignment_expression: prefix_expression (assignments+=assignment)*;

// Rule Assignment
assignment: type_=('=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=') right=conditional_expression;

/*
expression
	: primary_expression
	| expression postfix=('++' | '--')
	;
*/
// Rule ConditionalExpression
conditional_expression: concatenation_expression (op='?' conditional_expression ':' conditional_expression)?;

// Rule ConcatenationExpression
concatenation_expression: logical_or_expression (op='::' concatenation_expression)?;

// Rule LogicalOrExpression
logical_or_expression: logical_and_expression (op='||' logical_or_expression)?;

// Rule LogicalAndExpression
logical_and_expression: inclusive_or_expression (op='&&' logical_and_expression)?;

// Rule InclusiveOrExpression
inclusive_or_expression: exclusive_or_expression (op='|' inclusive_or_expression)?;

// Rule ExclusiveOrExpression
exclusive_or_expression: and_expression (op='^' exclusive_or_expression)?;

// Rule AndExpression
and_expression: equality_expression (op='&' and_expression)?;

// Rule EqualityExpression
equality_expression: relational_expression (op=('==' | '!=') equality_expression)?;

// Rule RelationalExpression
relational_expression: shift_expression (op=('<' | '>' | '<=' | '>=') relational_expression)?;

// Rule ShiftExpression
shift_expression: additive_expression (op=('<<' | '>>') shift_expression)?;

// Rule AdditiveExpression
additive_expression: multiplicative_expression (op=('+' | '-') additive_expression)?;

// Rule MultiplicativeExpression
multiplicative_expression: cast_expression (op=('*' | '/' |	'%') multiplicative_expression)?;

// Rule CastExpression
cast_expression:
	prefix_expression
	| '(' type_=type_specifier ')' cast_expression;

// Rule PrefixExpression
prefix_expression:
	postfix_expression
	| op='++' prefix_expression
	| op='--' prefix_expression
	| unary_operator cast_expression
	| op='sizeof' '(' (postfix_expression | type_specifier) ')';

// Rule UnaryOperator
unary_operator: '&' | '*' | '+' | '-' | '~' | '!';

// Rule PostfixExpression
postfix_expression: left=primary_expression post_op=postfix?;

// Rule Postfix
postfix:
	(op=RULE_LEFT_BR args+=conditional_expression (':' args+=conditional_expression)? RULE_RIGHT_BR
	| op='(' (args+=conditional_expression (',' args+=conditional_expression)*)? ')'
	| op='.' decl=RULE_ID
	| op='->' decl=RULE_ID
	| op='++'
	| op='--'
	)
	postfix?
;

// Rule PrimaryExpression
primary_expression:
	ref=RULE_ID
	| const_expr=constant
	| literal+=string_literal+
	| '(' conditional_expression ')'
;

// Rule StringLiteral
string_literal: RULE_ENCSTRINGCONST | RULE_STRING;

// Rule ConstantExpression
constant_expression: conditional_expression;

// Rule Constant
constant:
	integer_constant
	| floating_constant
	| character_constant
	| bool_constant
;

// Rule IntegerConstant
integer_constant:
	value=RULE_INTEGER
;

// Rule FloatingConstant
floating_constant:
	value=RULE_FLOAT
;

// Rule BoolConstant
bool_constant:
	value=RULE_BOOLEAN
;

// Rule CharacterConstant
character_constant:
	value=RULE_CHARCONST
;

// Rule DoubleLeftBracket
double_left_bracket:
	RULE_LEFT_BR
	RULE_LEFT_BR
;

// Rule DoubleRightBracket
double_right_bracket:
	RULE_RIGHT_BR
	RULE_RIGHT_BR
;

// Rule DataTypes
data_types:
	'bool'
	| 'char'
	| 'short'
	| 'int'
	| 'long'
	| 'signed'
	| 'unsigned'
	| 'float'
	| 'double'
	| 'void'
	| 'alias'
;

// Rule TypeQualifier
type_qualifier:
	'const'
	| 'volatile'
;

// Rule StorageClassSpecifier
storage_class_specifier:
	'extern'
	| 'static'
	| 'register'
;

// Rule attribute_name
attribute_name:
	'NONE'
	| 'is_pc'
	| 'is_interlock_for'
	| 'do_not_synthesize'
	| 'enable'
	| 'no_cont'
	| 'cond'
	| 'flush'
;

// Rule StructOrUnion
struct_or_union:
	'struct'
	| 'union'
;

RULE_LEFT_BR : '[';

RULE_RIGHT_BR : ']';

RULE_BOOLEAN : ('true'|'false');

RULE_FLOAT : ('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+'|'-')? ('0'..'9')+)? ('f'|'F'|'l'|'L')?;

RULE_INTEGER : (RULE_BINARYINT|RULE_HEXADECIMALINT|RULE_OCTALINT|RULE_DECIMALINT|RULE_VLOGINT) ('u'|'U')? (('l'|'L') ('l'|'L')?)?;

fragment RULE_BINARYINT : ('0b'|'0B') '0'..'1' ('_'? '0'..'1')*;

fragment RULE_OCTALINT : '0' '_'? '0'..'7' ('_'? '0'..'7')*;

fragment RULE_DECIMALINT : ('0'|'1'..'9' ('_'? '0'..'9')*);

fragment RULE_HEXADECIMALINT : ('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F') ('_'? ('0'..'9'|'a'..'f'|'A'..'F'))*;

fragment RULE_VLOGINT : ('0'..'9')+ '\'' ('b' ('0'..'1')+|'o' ('0'..'7')+|'d' ('0'..'9')+|'h' ('0'..'9'|'a'..'f'|'A'..'F')+);

RULE_CHARCONST : ('u'|'U'|'L')? '\'' ('\\' .|~('\\'|'\''))* '\'';

RULE_INT : '~this one has been deactivated';

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

RULE_ENCSTRINGCONST : ('u8'|'u'|'U'|'L') '"' ('\\' .|~('\\'|'"'))* '"';

RULE_STRING : ('"' ('\\' .|~('\\'|'"'))* '"'|'\'' ('\\' .|~('\\'|'\''))* '\'');

RULE_ML_COMMENT : '/*' .*?'*/' -> skip;

RULE_SL_COMMENT : '//' ~('\n'|'\r')* ('\r'? '\n')? -> skip;

RULE_WS : (' '|'\t'|'\r'|'\n')+ -> skip;

RULE_ANY_OTHER : .;
