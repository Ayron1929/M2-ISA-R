start: include* _isa+

include: "import" RULE_STRING

_isa: (instruction_set | core_def)

instruction_set: "InstructionSet" RULE_ID ("extends" RULE_ID)? "{" (section_arch_state (section_functions section_instructions? | section_instructions)? | section_functions (section_arch_state section_instructions? | section_instructions )? | section_instructions (section_arch_state section_functions? | section_functions)?) "}"
core_def: "Core" RULE_ID ("provides" RULE_ID ("," RULE_ID )*)? "{" (section_arch_state (section_functions section_instructions? | section_instructions)? | section_functions (section_arch_state section_instructions? | section_instructions )? | section_instructions (section_arch_state section_functions? | section_functions)?) "}"

section_arch_state: "architectural_state" "{" (declaration | expression_statement)+ "}"
section_functions: "functions" "{" function_definition+ "}"
section_instructions: "instructions" attribute* "{" instruction+ "}"

instruction: RULE_ID attribute* "{" "encoding" ":" encoding ";" ("args_disass" ":" RULE_STRING ";")? "behavior" ":" statement "}"
encoding: field ("::" field)*
field: bit_value | bit_field
bit_value: RULE_INTEGER
bit_field: RULE_ID RULE_LEFT_BR integer_constant ":" integer_constant RULE_RIGHT_BR

function_definition: "extern" type_specifier RULE_ID "(" parameter_list? ")" ";" -> extern_function_definition
	| type_specifier RULE_ID "(" parameter_list? ")" attribute* compound_statement

parameter_list: parameter_declaration ("," parameter_declaration)*
parameter_declaration: type_specifier (direct_declarator | abstract_declarator)?

statement: (compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement | spawn_statement)

labeled_statement: "case" constant_expression ":" statement*
	| "default" ":" statement*

compound_statement: "{" block_item* "}"
block_item: statement | declaration

expression_statement: expression_list? ";"
selection_statement: if_statement | switch_statement
if_statement: "if" "(" conditional_expression ")" statement ("else" statement)?
switch_statement: "switch" "(" conditional_expression ")" "{" labeled_statement+ "}"

iteration_statement: "while" "(" conditional_expression ")" statement -> while_pre_statement
	| "do" statement "while" "(" conditional_expression ")" ";" -> while_post_statement
	| "for" "(" for_condition ")" statement -> for_statement

for_condition: (declaration | assignment_expression? ";") conditional_expression? ";" (assignment_expression("," assignment_expression)*)?
jump_statement: "continue" ";" -> continue_statement
	| "break" ";" -> break_statement
	| "return" conditional_expression? ";" -> return_statement

spawn_statement: "spawn" statement

declaration: declaration_specifier* type_specifier ("*" | "&")? (init_declarator("," init_declarator)*)? ";"
declaration_specifier: (STORAGE_CLASS_SPECIFIER | TYPE_QUALIFIER | attribute)
attribute: double_left_bracket ATTRIBUTE_NAME ( "=" conditional_expression)? double_right_bracket

type_specifier: (primitive_type | composite_type | enum_type)

primitive_type: DATA_TYPES+ bit_size_specifier?
bit_size_specifier: "<" primary_expression ("," primary_expression "," primary_expression "," primary_expression)? ">"
enum_type: ("enum" RULE_ID? "{" enumerator_list ","? "}" | "enum" RULE_ID)
enumerator_list: enumerator ("," enumerator)*
enumerator: (RULE_ID | RULE_ID "=" constant_expression)

composite_type: (STRUCT_OR_UNION RULE_ID? "{" struct_declaration* "}" | STRUCT_OR_UNION RULE_ID)

struct_declaration: struct_declaration_specifier direct_declarator ("," direct_declarator)* ";"
struct_declaration_specifier: (type_specifier | TYPE_QUALIFIER)

init_declarator: direct_declarator attribute* ("=" initializer)?

direct_declarator: RULE_ID ( ":" integer_constant)? ((RULE_LEFT_BR conditional_expression RULE_RIGHT_BR)+ | "(" parameter_list ")")?

initializer: (conditional_expression | "{" initializer_list ","? "}")

initializer_list: (designated_initializer | initializer) ("," (designated_initializer | initializer))*

designated_initializer: designator+ "=" initializer

designator: (RULE_LEFT_BR constant_expression RULE_RIGHT_BR | "." RULE_ID)

abstract_declarator: direct_abstract_declarator

direct_abstract_declarator: ("(" (abstract_declarator? | parameter_list) ")" | RULE_LEFT_BR constant_expression? RULE_RIGHT_BR)


?expression_list: assignment_expression ("," assignment_expression)*
?assignment_expression: prefix_expression (assignment)*
?assignment: ASSIGNMENT_OP conditional_expression
ASSIGNMENT_OP: ("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=")

?conditional_expression: concatenation_expression ("?" conditional_expression ":" conditional_expression)?
?concatenation_expression: logical_or_expression ("::" concatenation_expression)?
?logical_or_expression: logical_and_expression ("||" logical_or_expression)?
?logical_and_expression: inclusive_or_expression ("&&" logical_and_expression)?
?inclusive_or_expression: exclusive_or_expression ("|" inclusive_or_expression)?
?exclusive_or_expression: and_expression ("^" exclusive_or_expression)?
?and_expression: equality_expression ("&" and_expression)?
?equality_expression: relational_expression (("==" | "!=") equality_expression)?
?relational_expression: shift_expression (("<" | ">" | "<=" | ">=") relational_expression)?
?shift_expression: additive_expression (("<<" | ">>") shift_expression)?
?additive_expression: multiplicative_expression (("+" | "-") additive_expression)?
?multiplicative_expression: cast_expression (("*" | "/" | "%") multiplicative_expression)?

?cast_expression: (prefix_expression | "(" type_specifier ")" cast_expression)
?prefix_expression: (postfix_expression | "++" prefix_expression | "--" prefix_expression | UNARY_OPERATOR cast_expression | "sizeof" "(" (postfix_expression | type_specifier) ")")

UNARY_OPERATOR: ("&" | "*" | "+" | "-" | "~" | "!")

?postfix_expression: primary_expression (postfix)?
postfix: (RULE_LEFT_BR conditional_expression (":" conditional_expression)? RULE_RIGHT_BR | "(" (conditional_expression ("," conditional_expression)*)? ")" | "." RULE_ID | "->" RULE_ID | "++" | "--") postfix?

?primary_expression: (RULE_ID | constant | string_literal+ | "(" conditional_expression ")")

string_literal: (RULE_ENCSTRINGCONST | RULE_STRING)

constant_expression: conditional_expression

constant: (integer_constant | floating_constant | character_constant | bool_constant)

integer_constant: RULE_INTEGER

floating_constant: RULE_FLOAT

bool_constant: RULE_BOOLEAN

character_constant: RULE_CHARCONST

double_left_bracket: RULE_LEFT_BR RULE_LEFT_BR

double_right_bracket: RULE_RIGHT_BR RULE_RIGHT_BR

DATA_TYPES: ("bool" | "char" | "short" | "int" | "long" | "signed" | "unsigned" | "float" | "double" | "void" | "alias")

TYPE_QUALIFIER: ("const" | "volatile")

STORAGE_CLASS_SPECIFIER: ("extern" | "static" | "register")

ATTRIBUTE_NAME: ("NONE" | "is_pc" | "is_interlock_for" | "do_not_synthesize" | "enable" | "no_cont" | "cond" | "flush")

STRUCT_OR_UNION: ("struct" | "union")

RULE_LEFT_BR : "["

RULE_RIGHT_BR : "]"

RULE_BOOLEAN : ("true"|"false")

RULE_FLOAT : ("0".."9")+ "." ("0".."9")* (("e"|"E") ("+"|"-")? ("0".."9")+)? ("f"|"F"|"l"|"L")?

RULE_INTEGER : (RULE_BINARYINT|RULE_HEXADECIMALINT|RULE_OCTALINT|RULE_DECIMALINT|RULE_VLOGINT) ("u"|"U")? (("l"|"L") ("l"|"L")?)?

RULE_BINARYINT : ("0b"|"0B") "0".."1" ("_"? "0".."1")*

RULE_OCTALINT : "0" "_"? "0".."7" ("_"? "0".."7")*

RULE_DECIMALINT : ("0"|"1".."9" ("_"? "0".."9")*)

RULE_HEXADECIMALINT : ("0x"|"0X") ("0".."9"|"a".."f"|"A".."F") ("_"? ("0".."9"|"a".."f"|"A".."F"))*

RULE_VLOGINT : ("0".."9")+ "\"" ("b" ("0".."1")+|"o" ("0".."7")+|"d" ("0".."9")+|"h" ("0".."9"|"a".."f"|"A".."F")+)

RULE_CHARCONST : /[uUL]?'(?:(?:\\.)|[^\\'])*'/

RULE_ID : "^"? ("a".."z"|"A".."Z"|"_") ("a".."z"|"A".."Z"|"_"|"0".."9")*

RULE_ENCSTRINGCONST : /(?:(?:u8)|[uUL])"(?:(?:\\.)|[^\\"])*"/

RULE_STRING : /(?:"(?:(?:\\.)|[^\\"])*")|(?:'(?:(?:\\.)|[^\\'])*')/

COMMENT: /\/\/.*/
ML_COMMENT: "/*" /(.|\n)+/ "*/"

%import common.WS

%ignore WS
%ignore COMMENT
%ignore ML_COMMENT

