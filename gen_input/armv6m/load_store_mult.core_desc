import "base.core_desc"

InstructionSet ARMv6M_Load_Store_Mult extends ARMv6M_Base {
    instructions {
        STM_T1 {
            encoding: b11000 | n[2:0] | reg_list[7:0];
            val address[32] <= R[n];
            val bits[32] <= bit_count(reg_list);

            if (reg_list & (1 << 0) != 0) {
                MEM[address]{32} <= R[0];
                address <= address + 4;
            }
            if (reg_list & (1 << 1) != 0) {
                MEM[address]{32} <= R[1];
                address <= address + 4;
            }
            if (reg_list & (1 << 2) != 0) {
                MEM[address]{32} <= R[2];
                address <= address + 4;
            }
            if (reg_list & (1 << 3) != 0) {
                MEM[address]{32} <= R[3];
                address <= address + 4;
            }
            if (reg_list & (1 << 4) != 0) {
                MEM[address]{32} <= R[4];
                address <= address + 4;
            }
            if (reg_list & (1 << 5) != 0) {
                MEM[address]{32} <= R[5];
                address <= address + 4;
            }
            if (reg_list & (1 << 6) != 0) {
                MEM[address]{32} <= R[6];
                address <= address + 4;
            }
            if (reg_list & (1 << 7) != 0) {
                MEM[address]{32} <= R[7];
                address <= address + 4;
            }

            R[n] <= R[n] + 4 * bits;
        }

        // LDM_T1

        PUSH_T1 {
            encoding: b1011010 | reg_list[14:14] | reg_list[7:0];

            val bits[32] <= bit_count(reg_list);
            val address[32] <= SP - 4 * bits;

            /*
            for (val i := 0 to 14) {
                if (reg_list & (1 << i) != 0) {
                    MEM[address]{32} <= R[i];
                    address <= address + 4;
                }
            }
            */

            if (reg_list & (1 << 0) != 0) {
                MEM[address]{32} <= R[0];
                address <= address + 4;
            }
            if (reg_list & (1 << 1) != 0) {
                MEM[address]{32} <= R[1];
                address <= address + 4;
            }
            if (reg_list & (1 << 2) != 0) {
                MEM[address]{32} <= R[2];
                address <= address + 4;
            }
            if (reg_list & (1 << 3) != 0) {
                MEM[address]{32} <= R[3];
                address <= address + 4;
            }
            if (reg_list & (1 << 4) != 0) {
                MEM[address]{32} <= R[4];
                address <= address + 4;
            }
            if (reg_list & (1 << 5) != 0) {
                MEM[address]{32} <= R[5];
                address <= address + 4;
            }
            if (reg_list & (1 << 6) != 0) {
                MEM[address]{32} <= R[6];
                address <= address + 4;
            }
            if (reg_list & (1 << 7) != 0) {
                MEM[address]{32} <= R[7];
                address <= address + 4;
            }
            if (reg_list & (1 << 14) != 0) {
                MEM[address]{32} <= LR;
                address <= address + 4;
            }

            SP <= SP - 4 * bits;
        }

        // POP_T1
    }
}