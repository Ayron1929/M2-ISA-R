import "RV32D.core_desc"

InstructionSet RV32DC extends RV32D {
    instructions{
        C.FLD { //(RV32/64)
            encoding: b001 | uimm[5:3] | rs1[2:0] | uimm[7:6] | rd[2:0] | b00;
            args_disass:"f(8+{rd}), {uimm}({name(8+rs1)})";
            val offs[XLEN] <= X[rs1+8]+uimm;
            val res[64] <= MEM[offs]{64};
            if(FLEN==64)
                F[rd+8] <= res;
            else { // NaN boxing
                val upper[FLEN] <= -1;
                F[rd+8] <= (upper<<64) | res;
            }
         }
        C.FSD { //(RV32/64)
            encoding: b101 | uimm[5:3] | rs1[2:0] | uimm[7:6] | rs2[2:0] | b00;
            args_disass:"f(8+{rs2}), {uimm}({name(8+rs1)})";
            val offs[XLEN] <= X[rs1+8]+uimm;
            MEM[offs]{64}<=F[rs2+8]{64};
        } 
        C.FLDSP {//(RV32/64)
            encoding:b001 | uimm[5:5] | rd[4:0] | uimm[4:3] | uimm[8:6] | b10;
            args_disass:"f{rd}, {uimm}(x2)";
            val offs[XLEN] <= X[2]+uimm;
            val res[64] <= MEM[offs]{64};
            if(FLEN==64)
                F[rd] <= res;
            else { // NaN boxing
                val upper[FLEN] <= -1;
                F[rd] <= (upper<<64) | zext(res, FLEN);
            }
        }
        C.FSDSP {//(RV32/64)
            encoding:b101 | uimm[5:3] | uimm[8:6] | rs2[4:0] | b10;
            args_disass:"f{rs2}, {uimm}(x2), ";
            val offs[XLEN] <= X[2]+uimm;
            MEM[offs]{64}<=F[rs2]{64};
        }
    }
}