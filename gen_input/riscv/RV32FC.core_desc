import "RV32F.core_desc"

InstructionSet RV32FC extends RV32F {
    instructions {
        C.FLW {
            encoding: b011 | uimm[5:3] | rs1[2:0] | uimm[2:2] | uimm[6:6] | rd[2:0] | b00;
            args_disass:"f(8+{rd}), {uimm}({name(8+rs1)})";
            val offs[XLEN] <= X[rs1+8]+uimm;
            val res[32] <= MEM[offs]{32};
            if(FLEN==32)
                F[rd+8] <= res;
            else { // NaN boxing
                val upper[FLEN] <= -1;
                F[rd+8] <= (upper<<32) | zext(res, FLEN);
            }
        } 
        C.FSW {
            encoding: b111 | uimm[5:3] | rs1[2:0] | uimm[2:2] | uimm[6:6] | rs2[2:0] | b00;
            args_disass:"f(8+{rs2}), {uimm}({name(8+rs1)})";
            val offs[XLEN] <= X[rs1+8]+uimm;
            MEM[offs]{32}<=F[rs2+8]{32};
        }
        C.FLWSP {
            encoding:b011 | uimm[5:5] | rd[4:0] | uimm[4:2] | uimm[7:6] | b10;
            args_disass:"f{rd}, {uimm}(x2)";
            val offs[XLEN] <= X[2]+uimm;
            val res[32] <= MEM[offs]{32};
            if(FLEN==32)
                F[rd] <= res;
            else { // NaN boxing
                val upper[FLEN] <= -1;
                F[rd] <= (upper<<32) | zext(res, FLEN);
            }
        }
        C.FSWSP {
            encoding:b111 | uimm[5:2] | uimm[7:6] | rs2[4:0] | b10;
            args_disass:"f{rs2}, {uimm}(x2), ";
            val offs[XLEN] <= X[2]+uimm;
            MEM[offs]{32}<=F[rs2]{32};
        }        
    }
}